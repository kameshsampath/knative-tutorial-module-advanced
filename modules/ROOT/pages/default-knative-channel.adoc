== Using Kafka Channel as Default Knative Channel
include::_attributes.adoc[]

https://developers.redhat.com/blog/2016/08/10/persistence-vs-durability-in-messaging/[Persistence and Durability] are two very important features of any messaging based architectures. The Knative Channel has built-in support for durability. Durability of messages becomes ineffective, if the Knative Eventing Channel does not support persistence. As without persistence it will not be able to deliver the messages to subscribers which might be  offline at the time of message delivery.

By default all Knative Channels created by the Knative Eventing API use InMemoryChannel(imc), which does not have capability to persist messages. To enable persistence we need to use one of the supported https://knative.dev/docs/eventing/channels/channels-crds/[channels] such as GCP PubSub, Kafka or Natss as the default Knative Channel backend.

We installed <<deploy-apache-kafka,Apache Kafka>>, earlier in this chapter, let us now configure it to be the default Knative Channel backend:

.Knative Default Channel ConfigMap
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: default-ch-webhook
  namespace: knative-eventing
data:
  default-ch-config: |
    clusterDefault: #<1>
      apiVersion: messaging.knative.dev/v1alpha1
      kind: InMemoryChannel
    namespaceDefaults: #<2>
      chapter-4:
        apiVersion: messaging.knative.dev/v1alpha1
        kind: KafkaChannel
        spec:
          numPartitions: 1
          replicationFactor: 1
----

<1> For the cluster we will still use the default InMemoryChannel
<2> For the namespace *{tutorial-namespace}*, all Knative Eventing Channels will use KafkaChannel as default

Run the following command apply the Knative Eventing Channel configuration:

[#eventing-default-channel-create]
[source,bash,subs="+quotes,attributes+,+macros"]
----
kubectl apply -f default-kafka-channel.yaml
----
copyToClipboard::eventing-default-channel-create[]

Since you have now made all Knative Eventing Channels of *{tutorial-namespace}* to be KafkaChannel, creating a Knative Eventing Channel in namespace *{tutorial-namespace}* will result in a corresponding Kafka Topic created. Let us now verify it by creating a sample Channel as show in listing,

.Create a example Channel
[source,yaml]
----
cat <<EOF | kubectl apply -f - 
apiVersion: messaging.knative.dev/v1alpha1
kind: Channel
metadata:
  name: my-events-ch
  namespace: {tutorial-namespace}
spec: {}
EOF
----

When you now list the topics that are available in Kafka using the script `$TUTORIAL_HOME/bin/kafka-list-topics.sh`, you should see a topic corresponding to your Channel `my-events-ch`:

.Listing Knative Eventing Channel Topics
[source,bash,subs="+quotes,attributes+,+macros"]
----
$ *$TUTORIAL_HOME/bin/kafka-list-topics.sh*
knative-messaging-kafka.{tutorial-namespace}.my-events-ch
----

For each Knative Eventing Channel that you will create, there will be a Kafka Topic created, the topic's name will follow a convention like `knative-messaging-kafka.<your-channel-namespace>.<your-channel-name>`.

== Cleanup
ifndef::workshop[]
[tabs]
====
kubectl::
+
--
[#eventing-default-channel-cleanup2]
[source,bash,subs="attributes+,+macros",linenums]
----
kubectl -n {tutorial-namespace} delete -f channels.messaging.knative.dev my-events-ch
----
copyToClipboard::eventing-default-channel-cleanup2[]

--
oc::
+
--
endif::[]
[#eventing-default-channel-cleanup-oc]
[source,bash,subs="attributes+,+macros",linenums]
----
kubectl -n {tutorial-namespace} delete -f channels.messaging.knative.dev my-events-ch
----
copyToClipboard::eventing-default-channel-cleanup-oc[]
ifndef::workshop[]
--
====